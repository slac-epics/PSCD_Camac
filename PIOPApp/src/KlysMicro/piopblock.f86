        INTEGER*4 FUNCTION PIOP_BLOCK (BLOCK_NAME, DUMMY, CAM_DATA)
C 
C       **MEMBER**=SLCRMX:KLYSLIB
C
C=======================================================================
C
C Reads PIOP in location PLOC into or from buffer DATA.
C
C Routine requires /KLYSDATA/ to contain valid data about unit
C
C Returns KLYS_OKOK        if okok.
C         KLYS_CAMAC_ERROR if bad block response
C         KLYS_PIOP_DEAD   if STATUS block has stale data
C         CAMAC_?????      if bad camac
C
C Calls ERR_SEND(KLYS_CAMAC_ERROR, ...) if CAMAC error occured,
C and STAT did not have stat_badcamac bit set.
C
C  BLOCK_NAME   is A4 type name of block.  ie.
C                          FTPB, CBLK, SBLK
C  DATA         is Z2 type array with/for data
C
C
C Note:  if the block is 'SBLK' -- routine reads block up three times
C        to avoid a conflict with the PIOP.
C
C        If the block is 'CBLK' -- routine waits 10 ms and then tries
C        again.
C
C
C Mod:  13-Mar-1996, Tony Gromme (TEG):
C           For compatibility with new MBCD, use just QM2,XM2 rather
C           than all of QM2,QM1,XM2,XM1.
C       12-Sep-1991, D. Van Olst (VANOLST):
C           Fix the situation where we have not been able to complete
C           the camac transaction that reads the SBLK in 'many' tries.
C           This is a software fix for what seems to be an unidentified
C           PIOP hardware problem, where the PIOP is still working but
C           unable to talk to the outside world via CAMAC.  IPLing
C           always seems to fix it.  See CATER 18403.
C       ??-Jun-1989, MICK
C           Check for stale status block data.
C       ??-Feb-1989, MICK
C           Change back to using qm2/xm2, and use also qm1/xm1.
C       ??-Aug-1988, RKJ, John Tinsman
C           Add diagnostic error message.
C       ??-Jul-1987, MICK
C           Suppress error message if STAT_DMTO set.
C       ??-Jul-1987, RKJ
C           Change camac use from dependency on qm2/xm2 to sensitivity
C           to q/x status as interpreted by the EMASK qualifier.
C=======================================================================
C
C CAMAC Logic as follows:
C
C We send a 2 packet package as follows:
C
C 1) Send F11, Byte Count = 0.  
C    Expect packet to terminate on BCNT, Q = X = 1.
C
C 2) Send F16 or F0, Byte Count = Exact.
C    Expect packet to terminate on BCNT, Q = X = 1.
C
C=======================================================================
 
        IMPLICIT INTEGER*2 (A-Z)
 
$ LIST
$        INCLUDE (SLCRMXI:CTLWBITS.INC)
$ LIST
$        INCLUDE (SLCRMXI:KLYSTATUS.INC)
$ LIST
$        INCLUDE (SLCRMXI:KLYSDATA.INC)
$ LIST
$        INCLUDE (SLCRMXI:KLYSUNITS.INC)
$ LIST
$ NOLIST INCLUDE (SLCRMXI:KLYSDEF.INC)
$ LIST

        INTEGER*2  BCNT_CBLK,      BCNT_FTPB,       BCNT_SBLK
        PARAMETER (BCNT_CBLK = 32, BCNT_FTPB = 134, BCNT_SBLK = 64)
C
C       Maximum number of duplicate status block reads before the PIOP
C       is considered to have crashed.  Set to tolerate 4 repeats.  The
C       5th repeat will cause an error.
C
        INTEGER*2  MAX_STATUS_BLOCK_REPEAT
        PARAMETER (MAX_STATUS_BLOCK_REPEAT = 4)

C       Maximum number of failures trying to get the status block
C       before the PIOP is considered to have crashed.

        INTEGER*2  MAX_STATUS_BLOCK_CAMAC_REPEAT 
        PARAMETER (MAX_STATUS_BLOCK_CAMAC_REPEAT = 36)
C
C       Mask to modify the crate and module number for the different
C       units.
C
        INTEGER*4  PMASK
        PARAMETER (PMASK = CRATE_MASK + MODULE_MASK)
C
C       Arguments.
C 
        INTEGER*4 BLOCK_NAME, DUMMY
        INTEGER*2 CAM_DATA (1)
C
C       2 words stat, no data
C       2 words stat, 67 w data (max)
C
        INTEGER*2 STAT_DATA1 (2), STAT_DATA2 (69)

        INTEGER*4 ISS
        LOGICAL*4 ILL
        EQUIVALENCE (ISS, ILL)

        LOGICAL*2 FIRST
        DATA      FIRST /.TRUE./

        INTEGER*2 CBLK_PTR, FTPB_PTR, SBLK_PTR
C
C       Time to wait between CBLK retries.
C
        INTEGER*4 CBLK_SLEEP
        DATA      CBLK_SLEEP /10/
C
C       Unique-ness counters for status block reads.  Value must be
C       different for each read.  If not, then the PIOP has crashed,
C       and CAMAC is considered as failing.
C
        INTEGER*2 STATUS_BLOCK_READ   (MAX_UNITS),
     >            STATUS_BLOCK_REPEAT (MAX_UNITS)

        DATA      STATUS_BLOCK_READ   /MAX_UNITS * 0/,
     >            STATUS_BLOCK_REPEAT /MAX_UNITS * 0/


C       Failure counter for status block reads.
C       

        INTEGER*2 STATUS_BLOCK_CAMAC_REPEAT (MAX_UNITS)
        DATA      STATUS_BLOCK_CAMAC_REPEAT /MAX_UNITS * 0/

C
C       External functions.
C
        INTEGER*4 CAMALO,
     >            CAMADD,
     >            CAMGO,
     >            CAMMOD,
     >            ERR_SEND2, ERR_SEND3, ERR_SEND4, ERR_SEND5
C
C=======================================================================
C
C       Build up three CAMAC packages for the three blocks.
C
        IF (FIRST) THEN
           FIRST = .FALSE.

           ISS = CAMALO (0, 2, CBLK_PTR)
           IF (ILL) ISS = CAMADD (F8+F2+F1 + A0, STAT_DATA1, 0, #F3C0H,
     >                            CBLK_PTR)
           IF (ILL) ISS = CAMADD (F16 + A0 + QM2 + XM2,
     >                            STAT_DATA2, BCNT_CBLK, #F3C0H,
     >                            CBLK_PTR)

           IF (ILL) ISS = CAMALO (0, 2, FTPB_PTR)
           IF (ILL) ISS = CAMADD (F8+F2+F1 + A1, STAT_DATA1, 0, #F3C0H,
     >                            FTPB_PTR)
           IF (ILL) ISS = CAMADD (F0 + A1 + QM2 + XM2,
     >                            STAT_DATA2, BCNT_FTPB, #F3C0H,
     >                            FTPB_PTR)

           IF (ILL) ISS = CAMALO (0, 2, SBLK_PTR)
           IF (ILL) ISS = CAMADD (F8+F2+F1 + A2, STAT_DATA1, 0, #F3C0H,
     >                            SBLK_PTR)
           IF (ILL) ISS = CAMADD (F0 + A2 + QM2 + XM2,
     >                            STAT_DATA2, BCNT_SBLK, #F3C0H,
     >                            SBLK_PTR)

           IF (.NOT. ILL) THEN
              PIOP_BLOCK = ERR_SEND5 (KLYS_BADBAD, 4HPIOP, 4H_BLO,
     >                                4HCK  , 4HSTAR, 4HTUP )
              GOTO 100
           ENDIF
        ENDIF     

C=======================================================================
C
C       Depending on the block name, we use one of the CAMAC packages.
C
C=======================================================================

        IF     (BLOCK_NAME .EQ. SBLK) THEN


C          Try three time to to read the status block:

           ISS = CAMMOD (PLOC, PMASK, SBLK_PTR)
           IF (.NOT. ILL) ISS = CAMGO (SBLK_PTR)
           IF (.NOT. ILL) ISS = CAMGO (SBLK_PTR)

C          The overall purpose of this following section 
C          is as follows: If we have not had the CAMAC
C          package work in a 'long time' then set a special status.
C
C          However, if it did work, check to see if the 
C          PIOP is running by checking a special word
C          that gets incremented if the PIOP is running.
C          If the PIOP is not running, set another special status.


C          If the CAMAC package failed three times:

           IF (.NOT.ILL) THEN

C             If the CAMAC package has not worked in 'too long',
C             set a special status:

              IF(STATUS_BLOCK_CAMAC_REPEAT (KSD_ENTRY) .GT.
     >           MAX_STATUS_BLOCK_CAMAC_REPEAT) THEN 

                 ISS = KLYS_NOCAMAC_SBLK

C             Otherwise, just increment the counter of the
C             number of times we have not had a successful
C             CAMAC package execution by 3:

              ELSE

                 STATUS_BLOCK_CAMAC_REPEAT( KSD_ENTRY) =
     >             STATUS_BLOCK_CAMAC_REPEAT( KSD_ENTRY) + 3

              END IF

C          Otherwise the CAMAC package ran O.K.:

           ELSE

C             We have had a successful CAMAC package execution,
C             (at least). Reset this counter.

              STATUS_BLOCK_CAMAC_REPEAT( KSD_ENTRY) = 0

C             If the status-block-write field changed,
C             reset the counter of the number of times the
C             status-block-write field has not changed.

              IF (STAT_DATA2 (20) .NE.
     >            STATUS_BLOCK_READ (KSD_ENTRY)) THEN
                 STATUS_BLOCK_READ   (KSD_ENTRY) = STAT_DATA2 (20)
                 STATUS_BLOCK_REPEAT (KSD_ENTRY) = 0

C             Otherwise, if the status-block-write field 
C             has not changed... 

              ELSE

C                Return a special status if the status-block-write
C                field has not changed in 'too long':

                 IF (STATUS_BLOCK_REPEAT (KSD_ENTRY) .GT.
     >               MAX_STATUS_BLOCK_REPEAT) THEN
                    ISS = KLYS_PIOP_DEAD

C                Otherwise, just increment the counter of the
C                number of times the status-block-write field
C                has not changed:

                 ELSE
                    STATUS_BLOCK_REPEAT (KSD_ENTRY) =
     >                               STATUS_BLOCK_REPEAT (KSD_ENTRY) + 1
                 ENDIF
              ENDIF
           ENDIF

        ELSEIF (BLOCK_NAME .EQ. FTPB) THEN
           ISS = CAMMOD (PLOC, PMASK, FTPB_PTR)

        ELSEIF (BLOCK_NAME .EQ. CBLK) THEN
           CALL COPYB (BCNT_CBLK, CAM_DATA (1), STAT_DATA2 (3))
           ISS = CAMMOD (PLOC, PMASK, CBLK_PTR)
           IF (.NOT. ILL) THEN
              CALL KLYS_UNLOCK
              CALL SLEEP_MS (CBLK_SLEEP)
              CALL KLYS_LOCK
              ISS = CAMGO (CBLK_PTR)
           ENDIF

        ELSE

           PIOP_BLOCK = ERR_SEND4 (KLYS_BADBAD,
     >                             4HPIOP, 4H BLO, 4HCK -, BLOCK_NAME)
           GOTO 100
        ENDIF
C        
C       Treat errors.
C
        IF (.NOT. ILL) THEN                                      
C
C          First check for special KLYS_NOCAMAC_SBLK error,
C          to make life simple.  We will issue this error
C          even if the STAT_BADCAMAC bit is set, because
C          the STAT_BADCAMAC bit will ALWAYS be set when
C          we get this error.  Even though some callers
C          bugger this bit on to suppress error messages,
C          KLYSTATUS does not do this for SBLK calls and
C          KLYSTATUS is the only SBLK caller and this error
C          only occurs for SBLK calls.  So we should be 
C          O.K.!

           IF (ISS .EQ. KLYS_NOCAMAC_SBLK) THEN
              IF ((STAT .AND. (STAT_DEAD + STAT_DMTO))
     >            .EQ. 0) THEN
C             We have not issued this error, so issue it.
                   PIOP_BLOCK = ERR_SEND3 (KLYS_NOCAMAC_SBLK, PRIM_NAME,
     >                    UNIT_NAME, MAX_STATUS_BLOCK_CAMAC_REPEAT)
              ELSE
                   PIOP_BLOCK = ISS                             
              END IF
C             Egress here so PIOP_BLOCK does not get trampled on.
              GOTO 100
           END IF 

C          We might not know about it.
C
           IF ((STAT .AND. (STAT_BADCAMAC + STAT_DEAD + STAT_DMTO))
     >         .EQ. 0) THEN
              IF (ISS .EQ. KLYS_PIOP_DEAD) THEN
                 PIOP_BLOCK = ERR_SEND2 (KLYS_PIOP_DEAD, PRIM_NAME,
     >                                   UNIT_NAME)
              ELSE
                 PIOP_BLOCK = ERR_SEND3 (KLYS_CAMAC_ERROR, PRIM_NAME,
     >                                   UNIT_NAME, BLOCK_NAME)
              ENDIF
           ELSE
C
C             Here we already know it (or STAT was fudged.  KLYSFTP).
C
              IF (ISS .EQ. KLYS_PIOP_DEAD) THEN
                 PIOP_BLOCK = ISS
              ELSE
                 PIOP_BLOCK = KLYS_CAMAC_ERROR
              ENDIF
           ENDIF
           GOTO 100
        ENDIF

C=======================================================================
C
C       Some blocks have data to be copied.
C
C=======================================================================

        IF (BLOCK_NAME .EQ. FTPB) THEN
           CALL COPYB (BCNT_FTPB, STAT_DATA2 (3), CAM_DATA (1))
        ELSEIF (BLOCK_NAME .EQ. SBLK) THEN
           CALL COPYB (BCNT_SBLK, STAT_DATA2 (3), CAM_DATA (1))
        ENDIF
 
        PIOP_BLOCK = KLYS_OKOK
 
100     RETURN

        END
                                                                                                                                                                                                                                                                                                                                                                                   