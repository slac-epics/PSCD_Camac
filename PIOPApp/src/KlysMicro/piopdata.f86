        INTEGER*4 FUNCTION PIOPDATA(PIOP_RAW_DATA)

**MEMBER**=SLCRMX:KLYSLIB
*
* routine mimics the VAX routine PIOP_DATA_GET routine which unloads
* and process the PIOP FTP data block.
*
* Values are extracted from the supplied buffer, and deposited into 
* the database as suggested by the following lookup tables.  Entries
* with database descriptors of "kdb_none" are not processed.
*
* kj -- may 87
*
*-------------------------------------------------------------------
*
* Modifications:
*
*      02-APR-1992, D. Vanolst (VANOLST)
*         Remove XTRA from processing so it can be used to track
*         KPHR delta's per NP. We do not want this module to 
*         trash the XTRA value that has been carefully placed there
*         by TRIM_PHASE to get trashed (and possibly sent up to the VAX).
*
*      30-JAN-1991, D. Vanolst (VANOLST)
*         Remove BVLT and BCUR from processing, since they are 
*         already being handled by KLYSTATUS.
*
*      03-AUG-1989, R. Hall
*         Changed to increment significant change counters.
*
*      13-JAN-1989, R. Hall
*         Replaced database put with references to the new value
*         array, which was previously initialized, updated by
*         KLYSTATUS and this routine, and is later put to the
*         database by routine DRIVER.
*
*===================================================================

        IMPLICIT INTEGER*2 (A-Z)

$ NOLIST INCLUDE (SLCRMXI:PIOPUNITS.INC)
$ list
$ NOLIST INCLUDE (SLCRMXI:KLYSDEF.INC)
$ list
$ NOLIST INCLUDE (SLCRMXI:KDBDEF.INC)
$ list
$ NOLIST INCLUDE (SLCRMXI:KLYSDATA.INC)
$ list
$ NOLIST INCLUDE (SLCRMXI:KLYSUNITS.INC)
$ list
$ NOLIST INCLUDE (SLCRMXI:KLYSDBUFF.INC)
$ list

        INTEGER*2 PIOP_RAW_DATA(1)

***        CHARACTER*8 PSECN

        INTEGER*4 DBPOLY, DBLIST, DBGET, ITEM, D_INDX, ENUM, SECN

        INTEGER*2 I, I_CNT, J
        INTEGER*2 ISECN
        INTEGER*2 I_DLIST

        REAL*4    R4, R4_1, R, VR

        INTEGER*2 N_PSECN
        PARAMETER (N_PSECN = 70)
***        CHARACTER*8 PSECNS (N_PSECN)
***        DATA        PSECNS  / 
***     >  'PAD_GND ','PAD_P15 ','PAD_N15 ','PAD_PN6 ','PAD_DAC ',
***     >  'PAD_TEMP','DRIV_CON','DELAYCON','MK_TEMP ','ANLG_GND',
***     >  'MK_P5   ','MK_P15  ','MK_N15  ','DRIVE_PK','BCURR_PK',
***     >  'FE_PK   ','RE_PK   ','BVOLT_PK','SPARE_PK','FTP_DATA',
***     >  'MK_P5REF','FOCUSMON','KLYS_VAC','WG_VAC  ','DELTTEMP',
***
***     >  'FOCUSCON','26      ','INPUTEMP','EXT_GND ','DIFF_GND',
***     >  'ATTN_CUR','HEATER  ','RF_GAIN ','BADCABLE','LINEAR  ',
***     >  'PSDACOK ','RATE_ACC','RF_PED  ','MODE    ','TIMSTAMP',
***     >  'RATE_MOD','TMASK   ','TMASK2  ','TMASK3  ','TMASK4  ',
***     >  '45      ','46      ','47      ','48      ','DRIV_NOW',
***
***     >  '50      ','KPHR_NOW','MK_24   ','MKBADCAB','54      ',
***     >  '55      ','56      ','57      ','RATELOST','59      ',
***     >  '60      ','61      ','62      ','EXTRA   ',
****   -- the following are special combinational analysis
***     >  'PERV_PK ','LOG_KVAC','LOG_WVAC','VOLTKVAC','VOLTWVAC',
***     >  'HEATER_V' /

        INTEGER*4 SECNS (N_PSECN) 
        DATA      SECNS  /                                       
     >   kdb_none,  kdb_none,  kdb_none,  kdb_none,  kdb_none,   
     >   kdb_TPAD,  kdb_none,  kdb_none,  kdb_TMK ,  kdb_none,   
     >   kdb_none,  kdb_none,  kdb_none,  kdb_DRPK,  kdb_none,   
     >   kdb_FEPK,  kdb_REPK,  kdb_none,  kdb_none,  kdb_none,   
     >   kdb_none,  kdb_FMON,  kdb_KVAC,  kdb_WVAC,  kdb_KDT ,   
                                                                 
     >   kdb_none,  kdb_none,  kdb_KIT ,  kdb_none,  kdb_none,   
***     >   kdb_none,  kdb_FILP,  kdb_RFMG,  kdb_none,  kdb_none,   
     >   kdb_none,  kdb_none,  kdb_RFMG,  kdb_none,  kdb_none,   
     >   kdb_none,  kdb_ARAT,  kdb_RFAP,  kdb_none,  kdb_none,   
     >   kdb_MRAT,  kdb_none,  kdb_none,  kdb_none,  kdb_none,   
     >   kdb_none,  kdb_none,  kdb_none,  kdb_none,  kdb_none,   
                                                                 
     >   kdb_none,  kdb_none,  kdb_none,  kdb_none,  kdb_none,   
     >   kdb_none,  kdb_none,  kdb_none,  kdb_LRAT,  kdb_none,   
     >   kdb_none,  kdb_BV  ,  kdb_BC  ,  kdb_XTRA,              
                                                                 
     >   kdb_PERV,  kdb_none,  kdb_none,  kdb_none,  kdb_none,   
     >   kdb_none  /                                             

        INTEGER*2 ISECNS (N_PSECN) 
        DATA      ISECNS  /                                       
     >   is_none,   is_none,   is_none,   is_none,   is_none,   
     >   is_TPAD,   is_none,   is_none,   is_TMK ,   is_none,   
     >   is_none,   is_none,   is_none,   is_DRPK,   is_none,   
     >   is_FEPK,   is_REPK,   is_none,   is_none,   is_none,   
     >   is_none,   is_FMON,   is_KVAC,   is_WVAC,   is_KDT ,   
                                                                 
     >   is_none,   is_none,   is_KIT ,   is_none,   is_none,   
***     >   is_none,   is_FILP,   is_RFMG,   is_none,   is_none,   
     >   is_none,   is_none,   is_RFMG,   is_none,   is_none,   
     >   is_none,   is_ARAT,   is_RFAP,   is_none,   is_none,   
     >   is_MRAT,   is_none,   is_none,   is_none,   is_none,   
     >   is_none,   is_none,   is_none,   is_none,   is_none,   
                                                                 
     >   is_none,   is_none,   is_none,   is_none,   is_none,   
     >   is_none,   is_none,   is_none,   is_LRAT,   is_none,   
     >   is_none,   is_BV  ,   is_BC  ,   is_XTRA,              
                                                                 
     >   is_PERV,   is_none,   is_none,   is_none,   is_none,   
     >   is_none  /                                             

        INTEGER*2 D_INDICIES(N_PSECN)  
        DATA      D_INDICIES /
     >     1,    2,    3,    4,    5,    6,    7,    8,    9,   10, 
     >    11,   12,   13,   14,   15,   16,   17,   18,   19,   20, 
     >    21,   22,   23,   24,   25,   26,   27,   28,   29,   30, 
     >    31,   32,   33,   34,   35,   36,   37,   38,   39,   40, 
     >    41,   42,   43,   44,   45,   46,   47,   48,   49,   50,  

     >    51,   52,   53,   54,   55,   56,   57,   58,   59,   60,  
     >    61,   62,   63,   64,  

     >     1,   23,   24,   23,   24,   32 /

*
* the following decode table:
* _VV Voltage value     _BC Beam Current        _BV Beam Voltage
* _FE Forward Power     _RE Reflected           _nn none
* _fi fill              _DR Drive               _PH Phase
* _I2 Integer*2         _TM Tmask (8 bytes)     _XT extra - r4=i2
* _HE HEater power      _KV Klystron Vacuum     _WV waveguide vacuum
* l.. Log10 of ..       v.. raw voltage of .. (vacuums only!)
* _PE Perveance

        INTEGER*2 
     >  type_VV, type_BC, type_FE, type_RE, type_BV, type_nn, type_HE, 
     >  type_PH, type_I2, type_TM, type_fi, type_DR, type_PE, type_XT, 
     >  type_KV, typelKV, typevKV, type_WV, typelWV, typevWV
        parameter(
     >  type_VV=1 , type_BC=2 , type_FE=3 , type_RE=4 , type_BV=5 , 
     >  type_nn=6 , type_HE=7 , type_PH=8 , type_I2=9 , type_TM=10, 
     >  type_fi=11, type_DR=12, type_PE=13, type_XT=14, type_KV=15, 
     >  typelKV=16, typevKV=17, type_WV=18, typelWV=19, typevWV=20 )

        INTEGER*2 TYPE(N_PSECN) 
        DATA      TYPE  /
     >  type_VV, type_VV, type_VV, type_VV, type_VV, 
     >  type_VV, type_VV, type_VV, type_VV, type_VV, 
     >  type_VV, type_VV, type_VV, type_VV, type_nn, 
     >  type_FE, type_RE, type_nn, type_nn, type_VV, 
     >  type_VV, type_VV, type_KV, type_WV, type_VV, 

     >  type_VV, type_nn, type_VV, type_VV, type_VV, 
     >  type_VV, type_HE, type_PH, type_I2, type_I2, 
     >  type_I2, type_I2, type_VV, type_I2, type_I2, 
     >  type_I2, type_TM, type_fi, type_fi, type_fi, 
     >  type_nn, type_nn, type_nn, type_nn, type_DR, 

     >  type_nn, type_PH, type_I2, type_I2, type_nn, 
     >  type_nn, type_nn, type_nn, type_I2, type_nn, 
     >  type_nn, type_BV, type_BC, type_XT, 

     >  type_PE, typelKV, typelWV, typevKV, typevWV, 
     >  type_VV /


*-----------------------------------------------------------------------
        LOGICAL FIRST
        DATA    FIRST /.TRUE./

        INTEGER*2 HEAT_LIST(4)
        DATA      HEAT_LIST(1) /4/
        
        INTEGER*4 DBG_SECNS(3)
        DATA DBG_SECNS / KDB_DIVR, KDB_CURR, KDB_PCVT /
                       
        INTEGER*2    EQ_DATA(8)
        DATA         EQ_DATA(1) /8/
        REAL*4       EQ_DIVR, EQ_CURR, EQ_PCVT
        EQUIVALENCE (EQ_DATA(3), EQ_DIVR),
     >              (EQ_DATA(5), EQ_CURR),
     >              (EQ_DATA(7), EQ_PCVT)

        INTEGER*2 THIS_ENTRY(N_PSECN), NUM_ENTRIES
        INTEGER*4 ISS
        LOGICAL   ILL
        EQUIVALENCE (ISS, ILL)

*-----------------------------------------------------------------------

* build up a list containing all the non-null entries.

        IF (FIRST) THEN
           FIRST = .FALSE.
           ISS = KLYS_OKOK
           NUM_ENTRIES = 0
           DO 100 ENUM = 1, N_PSECN

* do nothing when appropiate
              IF ((SECNS(ENUM) .ne. KDB_NONE) .AND.
     >           (ISECNS(ENUM) .ne. IS_NONE) ) THEN
                 NUM_ENTRIES = NUM_ENTRIES + 1
                 THIS_ENTRY(NUM_ENTRIES) = ENUM
              ENDIF
100        CONTINUE
        ENDIF

        
* get some constants that we are about to use

* get the heat list
        HEAT_LIST(2) = 0
        IF(ILL) ISS = DBLIST(HEAT_LIST(1), PRIMARY, 0, UNIT, KDB_HEAT)

* get the other data
        EQ_DATA(2) = 0
        DO 101 J = 1, 3
           IF(ILL) ISS = DBGET(EQ_DATA, PRIMARY, 0, UNIT, DBG_SECNS(J))
101     CONTINUE

* Loop over all canidates

        DO 200 I_CNT = 1, NUM_ENTRIES

           ENUM = THIS_ENTRY(I_CNT)

           SECN   = SECNS(ENUM)

           ISECN  = ISECNS(ENUM)

           D_INDX = D_INDICIES(ENUM)

***           PSECN  = PSECNS(ENUM)

* Real type items
           IF (TYPE(ENUM) .eq. type_VV .or.
     >         TYPE(ENUM) .eq. type_PH .or.
     >         TYPE(ENUM) .eq. type_HE .or.
     >         TYPE(ENUM) .eq. type_RE .or.
     >         TYPE(ENUM) .eq. type_FE .or.
     >         TYPE(ENUM) .eq. type_DR .or.
     >         TYPE(ENUM) .eq. type_XT ) THEN

              I_DLIST = ((DL_OFFSET(ISECN) / 2) * NUM_UNITS) + KSD_ENTRY

              IF (TYPE(ENUM) .eq. type_VV) THEN
                 R4NEW_D_LIST(I_DLIST) = VOLT_CONSTANT *
     >              PIOP_RAW_DATA(D_INDX)

              ELSEIF (TYPE(ENUM) .eq. type_PH) THEN
                 R4NEW_D_LIST(I_DLIST) = PHASE_CONSTANT *
     >              PIOP_RAW_DATA(D_INDX)

* heater
              ELSEIF (TYPE(ENUM) .eq. type_HE) THEN
                 R4_1 = VOLT_CONSTANT * PIOP_RAW_DATA(D_INDX)
                 ISS = DBPOLY(HEAT_LIST(3), R4_1,
     >              R4NEW_D_LIST(I_DLIST), R)

              ELSEIF (TYPE(ENUM) .eq. type_DR) THEN
                 R4NEW_D_LIST(I_DLIST) = DRIVE_CONSTANT *
     >            (#00FFH .AND. PIOP_RAW_DATA(D_INDX))

C Commented out while XTRA is used for delta KPHRs see TRIMPHASE - Vanolst
C             ELSEIF (TYPE(ENUM) .eq. type_XT) THEN
C                R4NEW_D_LIST(I_DLIST) = PIOP_RAW_DATA(D_INDX)

              ELSEIF (TYPE(ENUM) .eq. type_RE .or.
     >                TYPE(ENUM) .eq. type_FE ) THEN
                 IF (EQ_PCVT .lt. 0.1) THEN
                    R4NEW_D_LIST(I_DLIST) = VOLT_CONSTANT *
     >                   PIOP_RAW_DATA(D_INDX)
                 ELSE   
                    R4NEW_D_LIST(I_DLIST) = EQ_PCVT *
     >                (VOLT_CONSTANT*PIOP_RAW_DATA(D_INDX))**2
                    IF (TYPE(ENUM) .eq. type_RE) THEN
                       R4NEW_D_LIST(I_DLIST) =
     >                    R4NEW_D_LIST(I_DLIST) / 16.
                    ENDIF
                 ENDIF
              ENDIF
*
*             Check whether the analog value has changed significantly
*             enough to cause the VAX database to be updated
*
              CALL KLYS_UPDATE_CK(ISECN)

* Integer*2 entries
           ELSEIF (TYPE(ENUM) .eq. type_I2 ) THEN
              I_DLIST = (DL_OFFSET(ISECN) * NUM_UNITS) + KSD_ENTRY
              I2NEW_D_LIST(I_DLIST) = PIOP_RAW_DATA(D_INDX)
*
*             Check whether the analog value has changed significantly
*             enough to cause the VAX database to be updated
*
              CALL KLYS_UPDATE_CK(ISECN)

* TMSK's
           ELSEIF (TYPE(ENUM) .eq. type_TM ) THEN
*
*             If any word in the TMSK has changed, indicate that
*             the VAX database should be updated
*
              I_DLIST = (DL_OFFSET(ISECN) * NUM_UNITS) +
     >          ( (KSD_ENTRY - 1) * 4) + 1
              IF (ILL .AND.
     >          ((PIOP_RAW_DATA(D_INDX) .NE. I2NEW_D_LIST(I_DLIST)) .OR.
     >           (PIOP_RAW_DATA(D_INDX + 1) .NE.
     >               I2NEW_D_LIST(I_DLIST + 1)) .OR.
     >           (PIOP_RAW_DATA(D_INDX + 2) .NE.
     >               I2NEW_D_LIST(I_DLIST + 2)) .OR.
     >           (PIOP_RAW_DATA(D_INDX + 3) .NE.
     >               I2NEW_D_LIST(I_DLIST + 3) ) ) ) THEN
                 IF (.NOT. VAX_CMD) THEN
                    VALUE_CHANGED = .TRUE.
                    SECN_CHANGED = ISECN
                    UNIT_CHANGED = KSD_ENTRY
                    CALL KLYS_SIG_CHANGE( )
                    CALL NET_GET_TIME(TIME_CHANGED)
                    CALL COPYW(4, I2NEW_D_LIST(I_DLIST),
     >                 OLDVAL_CHANGED(1))
                    CALL COPYW(4, PIOP_RAW_DATA(D_INDX),
     >                 NEWVAL_CHANGED(1))
                 ENDIF
                 CALL COPYW(4, PIOP_RAW_DATA(D_INDX),
     >              I2NEW_D_LIST(I_DLIST) )
              ENDIF

* Beam Current, Voltage
           ELSEIF (TYPE(ENUM) .eq. type_BV .or.
     >             TYPE(ENUM) .eq. type_BC .or.
     >             TYPE(ENUM) .eq. type_PE) THEN

              I_DLIST = ((DL_OFFSET(ISECN) / 2) * NUM_UNITS) + KSD_ENTRY
* beam volts
              IF (TYPE(ENUM) .eq. type_BV) THEN
                 R4NEW_D_LIST(I_DLIST) = EQ_DIVR * VOLT_CONSTANT *
     >              10. * PIOP_RAW_DATA(D_INDX)
* beam current
              ELSEIF (TYPE(ENUM) .eq. type_BC) THEN
                 R4NEW_D_LIST(I_DLIST) = EQ_CURR * VOLT_CONSTANT *
     >              PIOP_RAW_DATA(D_INDX)
* perveance
              ELSE
                 IF (EQ_DIVR.gt.0. .and. PIOP_RAW_DATA(18).gt.0.) THEN
                    R4NEW_D_LIST(I_DLIST) = PIOP_RAW_DATA(15) *
     >                 EQ_CURR / ((PIOP_RAW_DATA(18) * EQ_DIVR)**1.5 
     >                     * SQRT (VOLT_CONSTANT))
                 ELSE
                    R4NEW_D_LIST(I_DLIST) = 1.E-6
                 ENDIF
              ENDIF
*
*             Check whether the analog value has changed significantly
*             enough to cause the VAX database to be updated
*
              CALL KLYS_UPDATE_CK(ISECN)

* Various Vacuums
           ELSEIF (TYPE(ENUM) .eq. type_KV .or.
     >             TYPE(ENUM) .eq. typelKV .or.
     >             TYPE(ENUM) .eq. typevKV .or.
     >             TYPE(ENUM) .eq. type_WV .or.
     >             TYPE(ENUM) .eq. typelWV .or.
     >             TYPE(ENUM) .eq. typevWV ) THEN

              I_DLIST = ((DL_OFFSET(ISECN) / 2) * NUM_UNITS) + KSD_ENTRY

              IF (TYPE(ENUM) .eq. type_KV .or.
     >            TYPE(ENUM) .eq. typelKV .or.
     >            TYPE(ENUM) .eq. typevKV ) THEN
* we read "10" volts for the 1 volt input into klystron vacuum.
                 R4NEW_D_LIST(I_DLIST) = VOLT_CONSTANT *
     >              PIOP_RAW_DATA(D_INDX) / 10.
              ELSE
                 R4NEW_D_LIST(I_DLIST)  = VOLT_CONSTANT *
     >              PIOP_RAW_DATA(D_INDX)
              ENDIF

* Bound voltage by reason
              R4NEW_D_LIST(I_DLIST) = MIN(MAX(R4NEW_D_LIST(I_DLIST),
     >           -15.), 15.)

* Convert to Torr
              IF (TYPE(ENUM) .eq. type_KV .or.
     >            TYPE(ENUM) .eq. typelKV ) THEN
* Convert this to 50e-8 torr for 1 real volt
                 R4NEW_D_LIST(I_DLIST) = R4NEW_D_LIST(I_DLIST)
     >              * 50.E-8

              ELSEIF (TYPE(ENUM) .eq. type_WV .or.
     >                TYPE(ENUM) .eq. typelWV ) THEN
* per koontz, the following formulia applies:
                 R4NEW_D_LIST(I_DLIST) = 3.6e-9 * 10.**( 0.96 *
     >              R4NEW_D_LIST(I_DLIST) )
              ENDIF

* try to take a log
              IF (TYPE(ENUM) .eq. typelKV .or.
     >            TYPE(ENUM) .eq. typelWV ) THEN
                IF (R4NEW_D_LIST(I_DLIST) .lt. .1) THEN
                  R4NEW_D_LIST(I_DLIST) = LOG10( MAX(1.E-10,
     >               R4NEW_D_LIST(I_DLIST)) )
                ELSE
                  R4NEW_D_LIST(I_DLIST) = 0.00
                ENDIF
              ENDIF
*
*             Check whether the analog value has changed significantly
*             enough to cause the VAX database to be updated
*
              CALL KLYS_UPDATE_CK(ISECN)

           ELSE

              GOTO 200

           ENDIF


200     CONTINUE

        IF (ILL) THEN
           PIOPDATA = KLYS_OKOK
        ELSE
           PIOPDATA = KLYS_DB
           STATUS_SUMMARY = MAX0(KLYS_DB, STATUS_SUMMARY)
        ENDIF

        END
                                                                                                                                                                                                                                                                                                                                                                                                                                     